rules_version = '2';

// Firestore security rules for AuditSim Pro
// Admins can manage all data. Trainees may only
// access cases they are authorized for and their own submissions. Roles are enforced via roles/{uid} documents.
service cloud.firestore {
  match /databases/{database}/documents {
    // Role helpers (supports both custom claims and Firestore mirror)
    function roleEquals(roleValue, expected) {
      return roleValue is string && roleValue.matches('(?i)^' + expected + '$');
    }

    function getRoleFromDoc() {
      return request.auth != null
        ? get(/databases/$(database)/documents/roles/$(request.auth.uid)).data.role
        : null;
    }

    function hasRole(expected) {
      return request.auth != null && (
        roleEquals(request.auth.token.role, expected) ||
        roleEquals(getRoleFromDoc(), expected)
      );
    }

    function isAdmin() {
      return hasRole('admin');
    }

    function isTrainee() {
      return hasRole('trainee');
    }

    // Checks if the trainee can view the case currently being read
    function traineeCaseAccessible() {
      return (
        !(resource.data.visibleToUserIds is list) ||
        resource.data.visibleToUserIds.size() == 0 ||
        request.auth.uid in resource.data.visibleToUserIds
      );
    }

    function isValidSupportingDocument(doc) {
      return doc is map &&
             (!('storagePath' in doc) || doc.storagePath == null || doc.storagePath is string) &&
             (!('downloadURL' in doc) || doc.downloadURL == null || doc.downloadURL is string) &&
             (!('fileName' in doc) || doc.fileName == null || doc.fileName is string) &&
             (!('contentType' in doc) || doc.contentType == null || doc.contentType is string);
    }

    function isValidAnswerKey(ak) {
      return ak is map &&
             (!('properlyIncluded' in ak) || ak.properlyIncluded == null || ak.properlyIncluded is number) &&
             (!('properlyExcluded' in ak) || ak.properlyExcluded == null || ak.properlyExcluded is number) &&
             (!('improperlyIncluded' in ak) || ak.improperlyIncluded == null || ak.improperlyIncluded is number) &&
             (!('improperlyExcluded' in ak) || ak.improperlyExcluded == null || ak.improperlyExcluded is number) &&
             (!('explanation' in ak) || ak.explanation == null || ak.explanation is string);
    }

    function isValidDisbursementRecord(d) {
      return d is map &&
             d.keys().hasAll(['paymentId', 'payee', 'amount', 'paymentDate']) &&
             d.paymentId is string &&
             d.payee is string &&
             (d.amount is string || d.amount is number) &&
             d.paymentDate is string &&
             (!('expectedClassification' in d) || d.expectedClassification == null || d.expectedClassification is string) &&
             (!('answerKey' in d) || d.answerKey == null || isValidAnswerKey(d.answerKey)) &&
             (!('storagePath' in d) || d.storagePath == null || d.storagePath is string) &&
             (!('downloadURL' in d) || d.downloadURL == null || d.downloadURL is string) &&
             (!('fileName' in d) || d.fileName == null || d.fileName is string) &&
             (!('contentType' in d) || d.contentType == null || d.contentType is string) &&
             (!('supportingDocuments' in d) || (
               d.supportingDocuments is list &&
               (
                 d.supportingDocuments.size() == 0 ||
                 isValidSupportingDocument(d.supportingDocuments[0])
               )
             )) &&
             (!('description' in d) || d.description == null || d.description is string) &&
             (!('notes' in d) || d.notes == null || d.notes is string) &&
             (!('meta' in d) || d.meta == null || d.meta is map);
    }

    function isValidInvoiceMapping(m) {
      return m is map &&
             m.keys().hasAll(['paymentId']) &&
             m.paymentId is string &&
             (!('storagePath' in m) || m.storagePath == null || m.storagePath is string) &&
             (!('downloadURL' in m) || m.downloadURL == null || m.downloadURL is string) &&
             (!('fileName' in m) || m.fileName == null || m.fileName is string) &&
             (!('contentType' in m) || m.contentType == null || m.contentType is string);
    }

    function isValidClassificationDraftEntry(entry) {
      return entry is map &&
             (entry.keys().size() == 0 || ((entry[entry.keys()[0]] == null) || (entry[entry.keys()[0]] is string)));
    }

    function isValidProgressDraft(draft) {
      return draft is map &&
             (!('selectedPaymentIds' in draft) || (
               draft.selectedPaymentIds is list &&
               (draft.selectedPaymentIds.size() == 0 || draft.selectedPaymentIds[0] is string)
             )) &&
             (!('classificationDraft' in draft) || (
               draft.classificationDraft is map &&
               (
                 draft.classificationDraft.keys().size() == 0 ||
                 isValidClassificationDraftEntry(draft.classificationDraft[draft.classificationDraft.keys()[0]])
               )
             ));
    }

    function isValidProgressDocument(data) {
      return data.state in ['not_started', 'in_progress', 'submitted'] &&
             data.percentComplete >= 0 && data.percentComplete <= 100 &&
             (!('step' in data) || data.step in ['selection', 'support', 'testing', 'results']) &&
             (!('draft' in data) || isValidProgressDraft(data.draft));
    }

    function isValidCaseDocument() {
      return request.resource.data.keys().hasAll(['publicVisible', 'status', '_deleted', 'updatedAt', 'createdAt']) &&
             request.resource.data.publicVisible is bool &&
             request.resource.data._deleted is bool &&
             request.resource.data.status in ['assigned', 'in_progress', 'submitted', 'archived', 'draft'] &&
             request.resource.data.updatedAt is timestamp &&
             request.resource.data.createdAt is timestamp &&
             (!('createdBy' in request.resource.data) || request.resource.data.createdBy == null || request.resource.data.createdBy is string) &&
             (!('dueAt' in request.resource.data) || request.resource.data.dueAt == null || request.resource.data.dueAt is timestamp) &&
             (!('opensAt' in request.resource.data) || request.resource.data.opensAt == null || request.resource.data.opensAt is timestamp) &&
             (!('disbursements' in request.resource.data) || (
               request.resource.data.disbursements is list &&
               (
                 request.resource.data.disbursements.size() == 0 ||
                 isValidDisbursementRecord(request.resource.data.disbursements[0])
               )
             )) &&
             (!('invoiceMappings' in request.resource.data) || (
               request.resource.data.invoiceMappings is list &&
               (
                 request.resource.data.invoiceMappings.size() == 0 ||
                 isValidInvoiceMapping(request.resource.data.invoiceMappings[0])
               )
             ));
    }

    // Role documents store whether a user is an admin or trainee
    match /roles/{userId} {
      // Allow users to read their own role document (for display/initial setup)
      allow read: if request.auth != null && request.auth.uid == userId;
      // Allow a user to create their own role document with any role.
      allow create: if request.auth != null && request.auth.uid == userId;
      // Role updates should primarily be handled by a trusted backend service (e.g., Cloud Function)
      allow update: if request.auth != null && isAdmin(); // Still allow admin client-side if needed, but custom claims are source of truth
    }

    // Case documents accessible to trainees if authorized
    match /artifacts/{appId}/public/data/cases/{caseId} {
      // For single document reads, the function is secure.
      allow get: if request.auth != null && (
        isAdmin() ||
        (isTrainee() && traineeCaseAccessible())
      );
      // For queries, client must filter by visibleToUserIds to get results.
      allow list: if request.auth != null && (isAdmin() || isTrainee());
      allow create, update: if request.auth != null && isAdmin() && isValidCaseDocument();
      allow delete: if request.auth != null && isAdmin();
    }

    // Profile information is private to each user
    match /artifacts/{appId}/users/{userId} {
      allow read: if request.auth != null && isAdmin();
      allow write: if false;
    }

    match /artifacts/{appId}/users/{userId}/userProfileData/profile {
      allow read: if request.auth != null && (request.auth.uid == userId || isAdmin());
      allow write: if request.auth != null && request.auth.uid == userId;
    }

    function isSubmissionOwner(path) {
      return request.auth != null &&
             request.auth.uid is string &&
             path.matches('^artifacts/[^/]+/users/' + request.auth.uid + '$');
    }

    // Trainees submit their work under this path
    match /artifacts/{appId}/users/{userId}/caseSubmissions/{caseId} {
      allow read: if request.auth != null && (isAdmin() || request.auth.uid == userId);
      allow write: if request.auth != null && request.auth.uid == userId && isTrainee();
    }

    match /{path=**}/caseSubmissions/{caseId} {
      allow read: if request.auth != null && (isAdmin() || isSubmissionOwner(path));
      allow write: if request.auth != null && isSubmissionOwner(path) && isTrainee();
    }


    // Student progress is private to each user
    match /artifacts/{appId}/student_progress/{uid}/cases/{caseId} {
      allow read, write: if request.auth != null && request.auth.uid == uid;
      // validation
      allow create, update: if isValidProgressDocument(request.resource.data) &&
                               request.resource.data.updatedAt == request.time;
    }


    // Deny all other access by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
